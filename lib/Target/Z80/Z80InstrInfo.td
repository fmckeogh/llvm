//===-- Z80InstrInfo.td - Main Z80 Instruction Definition --*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file describes the Z80 instruction set, defining the instructions, and
// properties of the instructions which are needed for code generation, machine
// code emission, and analysis.
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Type Constraints.
//===----------------------------------------------------------------------===//
class SDTCisChain<int OpNum> : SDTCisVT<OpNum, OtherVT>;
class SDTCisI8   <int OpNum> : SDTCisVT<OpNum, i8>;
class SDTCisFlag <int OpNum> : SDTCisI8<OpNum>;
class SDTCisI16  <int OpNum> : SDTCisVT<OpNum, i16>;
class SDTCisI24  <int OpNum> : SDTCisVT<OpNum, i24>;
class SDTCisPtr  <int OpNum> : SDTCisVT<OpNum, iPTR>;

//===----------------------------------------------------------------------===//
// Type Profiles.
//===----------------------------------------------------------------------===//
def SDTUnOpRF   : SDTypeProfile<2, 1, [SDTCisInt<0>,
                                       SDTCisFlag<1>,
                                       SDTCisSameAs<2, 0>]>;
def SDTUnOpRFF  : SDTypeProfile<2, 2, [SDTCisInt<0>,
                                       SDTCisFlag<1>,
                                       SDTCisSameAs<2, 0>,
                                       SDTCisFlag<3>]>;
def SDTBinOpRF  : SDTypeProfile<2, 2, [SDTCisInt<0>,
                                       SDTCisFlag<1>,
                                       SDTCisSameAs<2, 0>,
                                       SDTCisSameAs<3, 0>]>;
def SDTBinOpRFF : SDTypeProfile<2, 3, [SDTCisInt<0>,
                                       SDTCisFlag<1>,
                                       SDTCisSameAs<2, 0>,
                                       SDTCisSameAs<3, 0>,
                                       SDTCisFlag<4>]>;
def SDTBinOpF   : SDTypeProfile<1, 2, [SDTCisFlag<0>,
                                       SDTCisInt<1>,
                                       SDTCisSameAs<2, 1>]>;

def SDTZ80Wrapper       : SDTypeProfile<1, 1, [SDTCisPtrTy<0>,
                                               SDTCisSameAs<1, 0>]>;
def SDT_Z80mlt          : SDTypeProfile<1, 1, [SDTCisI16<0>, SDTCisI16<1>]>;
def SDT_Z80sext         : SDTypeProfile<1, 1, [SDTCisInt<0>, SDTCisFlag<1>]>;
def SDT_Z80TCRet        : SDTypeProfile<0, 1, [SDTCisPtrTy<0>]>;
def SDT_Z80Call         : SDTypeProfile<0, -1, [SDTCisPtr<0>]>;
def SDT_Z80CallSeqStart : SDCallSeqStart<[SDTCisPtr<0>, SDTCisPtr<1>]>;
def SDT_Z80CallSeqEnd   : SDCallSeqEnd<[SDTCisPtr<0>, SDTCisPtr<1>]>;
def SDT_Z80BrCond       : SDTypeProfile<0, 3, [SDTCisChain<0>,
                                               SDTCisI8<1>,
                                               SDTCisFlag<2>]>;
def SDT_Z80Select       : SDTypeProfile<1, 4, [SDTCisInt<0>,
                                               SDTCisSameAs<1, 0>,
                                               SDTCisSameAs<2, 0>,
                                               SDTCisI8<3>,
                                               SDTCisI8<4>]>;
def SDT_Z80Pop          : SDTypeProfile<1, 0, [SDTCisPtr<0>]>;
def SDT_Z80Push         : SDTypeProfile<0, 1, [SDTCisPtr<0>]>;

//===----------------------------------------------------------------------===//
// Z80 specific DAG Nodes.
//

def Z80Wrapper       : SDNode<"Z80ISD::Wrapper", SDTZ80Wrapper>;
def Z80rlc_flag      : SDNode<"Z80ISD::RLC",     SDTUnOpRF>;
def Z80rrc_flag      : SDNode<"Z80ISD::RRC",     SDTUnOpRF>;
def Z80rl_flag       : SDNode<"Z80ISD::RL",      SDTUnOpRFF>;
def Z80rr_flag       : SDNode<"Z80ISD::RR",      SDTUnOpRFF>;
def Z80sla_flag      : SDNode<"Z80ISD::SLA",     SDTUnOpRF>;
def Z80sra_flag      : SDNode<"Z80ISD::SRA",     SDTUnOpRF>;
def Z80srl_flag      : SDNode<"Z80ISD::SRL",     SDTUnOpRF>;
def Z80inc_flag      : SDNode<"Z80ISD::INC",     SDTUnOpRF>;
def Z80dec_flag      : SDNode<"Z80ISD::DEC",     SDTUnOpRF>;
def Z80add_flag      : SDNode<"Z80ISD::ADD",     SDTBinOpRF, [SDNPCommutative]>;
def Z80adc_flag      : SDNode<"Z80ISD::ADC",     SDTBinOpRFF>;
def Z80sub_flag      : SDNode<"Z80ISD::SUB",     SDTBinOpRF>;
def Z80sbc_flag      : SDNode<"Z80ISD::SBC",     SDTBinOpRFF>;
def Z80and_flag      : SDNode<"Z80ISD::AND",     SDTBinOpRF, [SDNPCommutative]>;
def Z80xor_flag      : SDNode<"Z80ISD::XOR",     SDTBinOpRF, [SDNPCommutative]>;
def Z80or_flag       : SDNode<"Z80ISD::OR",      SDTBinOpRF, [SDNPCommutative]>;
def Z80cp_flag       : SDNode<"Z80ISD::CP",      SDTBinOpF>;
def Z80tst_flag      : SDNode<"Z80ISD::TST",     SDTBinOpF,  [SDNPCommutative]>;
def Z80mlt           : SDNode<"Z80ISD::MLT",     SDT_Z80mlt>;
def Z80sext          : SDNode<"Z80ISD::SEXT",    SDT_Z80sext>;
def Z80retflag       : SDNode<"Z80ISD::RET_FLAG", SDTNone,
                              [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
def Z80retnflag      : SDNode<"Z80ISD::RETN_FLAG", SDTNone,
                              [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
def Z80retiflag      : SDNode<"Z80ISD::RETI_FLAG", SDTNone,
                              [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
def Z80tcret         : SDNode<"Z80ISD::TC_RETURN", SDT_Z80TCRet,
                              [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
def Z80call          : SDNode<"Z80ISD::CALL", SDT_Z80Call,
                              [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue,
                               SDNPVariadic]>;
def Z80callseq_start : SDNode<"ISD::CALLSEQ_START", SDT_Z80CallSeqStart,
                              [SDNPHasChain, SDNPOutGlue]>;
def Z80callseq_end   : SDNode<"ISD::CALLSEQ_END", SDT_Z80CallSeqEnd,
                              [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;
def Z80brcond        : SDNode<"Z80ISD::BRCOND", SDT_Z80BrCond, [SDNPHasChain]>;
def Z80select        : SDNode<"Z80ISD::SELECT", SDT_Z80Select>;
def Z80pop           : SDNode<"Z80ISD::POP", SDT_Z80Pop,
                              [SDNPHasChain, SDNPMayLoad]>;
def Z80push          : SDNode<"Z80ISD::PUSH", SDT_Z80Push,
                              [SDNPHasChain, SDNPMayStore]>;

//===----------------------------------------------------------------------===//
// Z80 Instruction Predicate Definitions.
//
def In16BitMode  : Predicate<"Subtarget->is16Bit()">,
                   AssemblerPredicate<"Mode16Bit", "16-bit mode">;
def In24BitMode  : Predicate<"Subtarget->is24Bit()">,
                   AssemblerPredicate<"Mode24Bit", "24-bit mode">;
def HaveUndocOps : Predicate<"Subtarget->hasUndocOps()">,
                   AssemblerPredicate<"FeatureUndoc", "undocumented ops">;
def HaveZ180Ops  : Predicate<"Subtarget->hasZ180Ops()">,
                   AssemblerPredicate<"FeatureZ180", "Z180 ops">;
def HaveEZ80Ops  : Predicate<"Subtarget->hasEZ80Ops()">,
                   AssemblerPredicate<"FeatureEZ80", "eZ80 ops">;
def HaveIdxHalf  : Predicate<"Subtarget->hasIndexHalfRegs()">,
                   AssemblerPredicate<"FeatureIdxHalf", "index half regs">;

//===----------------------------------------------------------------------===//
// Z80 Instruction Format Definitions.
//

include "Z80InstrFormats.td"

//===----------------------------------------------------------------------===//
// Pattern fragments.
//

// Z80 specific condition code. These correspond to CondCode in
// Z80InstrInfo.h. They must be kept in synch.
def Z80_COND_NZ : PatLeaf<(i8 0)>;
def Z80_COND_Z  : PatLeaf<(i8 1)>;
def Z80_COND_NC : PatLeaf<(i8 2)>;
def Z80_COND_C  : PatLeaf<(i8 3)>;
def Z80_COND_PO : PatLeaf<(i8 4)>;
def Z80_COND_PE : PatLeaf<(i8 5)>;
def Z80_COND_P  : PatLeaf<(i8 6)>;
def Z80_COND_M  : PatLeaf<(i8 7)>;

//===----------------------------------------------------------------------===//
// Z80 Operand Definitions.
//

def aptr_rc : PointerLikeRegClass<1>;
def iptr_rc : PointerLikeRegClass<2>;

def mem : Operand<iPTR> {
  let PrintMethod = "printMem";
  let MIOperandInfo = (ops imm);
  let OperandType = "OPERAND_MEMORY";
}
def ptr : Operand<iPTR> {
  let PrintMethod = "printPtr";
  let MIOperandInfo = (ops aptr_rc);
  let OperandType = "OPERAND_MEMORY";
}
def off : Operand<iPTR> {
  let PrintMethod = "printOff";
  let MIOperandInfo = (ops iptr_rc, i8imm);
  let OperandType = "OPERAND_MEMORY";
}
def off16 : Operand<i16> {
  let PrintMethod = "printAddr";
  let MIOperandInfo = (ops I16, i8imm);
}
def off24 : Operand<i24> {
  let PrintMethod = "printAddr";
  let MIOperandInfo = (ops I24, i8imm);
}

let OperandType = "OPERAND_IMMEDIATE" in def i24imm : Operand<i24>;

def jmptarget : Operand<OtherVT>;
def jmptargetoff : Operand<OtherVT>;

def cc : Operand<i8> {
  let PrintMethod = "printCCOperand";
}

//===----------------------------------------------------------------------===//
// Pattern Fragments.
//
def imm_long_XFORM : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getZExtValue() & 0xffffff,
                                   SDLoc(N), MVT::i24);
}]>;
def imm_top_XFORM : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getZExtValue() >> 24, SDLoc(N), MVT::i8);
}]>;

//===----------------------------------------------------------------------===//
// Z80 Complex Pattern Definitions.
//
def mempat : ComplexPattern<iPTR, 1, "SelectMem",
                            [imm, globaladdr, externalsym]>;
def offpat : ComplexPattern<iPTR, 2, "SelectOff",
                            [add, sub, frameindex]>;

//===----------------------------------------------------------------------===//
// Instruction list.
//

let hasPostISelHook = 1 in {
  let Defs = [SPS, F], Uses = [SPS] in {
  def ADJCALLSTACKDOWN16 : P<(outs), (ins i16imm:$amt1, i16imm:$amt2),
                             [(Z80callseq_start timm:$amt1, timm:$amt2)]>,
                           Requires<[In16BitMode]>;
  def ADJCALLSTACKUP16   : P<(outs), (ins i16imm:$amt1, i16imm:$amt2),
                             [(Z80callseq_end timm:$amt1, timm:$amt2)]>,
                           Requires<[In16BitMode]>;
  }
  let Defs = [SPL, F], Uses = [SPL] in {
  def ADJCALLSTACKDOWN24 : P<(outs), (ins i24imm:$amt1, i24imm:$amt2),
                             [(Z80callseq_start timm:$amt1, timm:$amt2)]>,
                           Requires<[In24BitMode]>;
  def ADJCALLSTACKUP24   : P<(outs), (ins i24imm:$amt1, i24imm:$amt2),
                             [(Z80callseq_end timm:$amt1, timm:$amt2)]>,
                           Requires<[In24BitMode]>;
  }
}
let usesCustomInserter = 1 in {
  let Uses = [F] in {
    def Select8  : P<(outs  R8:$dst), (ins  R8:$true,  R8:$false, i8imm:$cc),
                     [(set  R8:$dst, (Z80select  R8:$true,  R8:$false, imm:$cc,
                                      F))]>;
    def Select16 : P<(outs R16:$dst), (ins R16:$true, R16:$false, i8imm:$cc),
                     [(set R16:$dst, (Z80select R16:$true, R16:$false, imm:$cc,
                                      F))]>;
    def Select24 : P<(outs R24:$dst), (ins R24:$true, R24:$false, i8imm:$cc),
                     [(set R24:$dst, (Z80select R24:$true, R24:$false, imm:$cc,
                                      F))]>,
                     Requires<[In24BitMode]>;
  }
  let Uses = [F] in {
    let Defs = [A]   in def SExt8  : P<(outs), (ins), [(set A,   (Z80sext F))]>;
    let Defs = [HL]  in def SExt16 : P<(outs), (ins), [(set HL,  (Z80sext F))]>;
    let Defs = [UHL] in def SExt24 : P<(outs), (ins), [(set UHL, (Z80sext F))]>;
  }
}

let hasSideEffects = 0 in
def NOP : I<NoPre, 0x00, "nop">;
def DI  : I<NoPre, 0xF3, "di">;
def EI  : I<NoPre, 0xFB, "ei">;

//===----------------------------------------------------------------------===//
//  Control Flow Instructions.
//

// All calls clobber the non-callee saved registers.  SP is marked as a use to
// prevent stack-pointer assignments that appear immediately before calls from
// potentially appearing dead.  Uses for argument registers are added manually.
let isCall = 1 in {
  let Uses = [SPS] in {
    def CALL16i : I16i<NoPre, 0xCD, "call", "\t$dst", "",
                       (outs), (ins i16imm:$dst), [(Z80call mempat:$dst)]>,
                  Requires<[In16BitMode]>;
    def CALL16r : P   <(outs), (ins    A16:$dst), [(Z80call    A16:$dst)]>,
                  Requires<[In16BitMode]>;
  }
  let Uses = [SPL] in {
    def CALL24i : I24i<NoPre, 0xCD, "call", "\t$dst", "",
                       (outs), (ins i24imm:$dst), [(Z80call mempat:$dst)]>;
    def CALL24r : P   <(outs), (ins    A24:$dst), [(Z80call    A24:$dst)]>;
  }
}

let isTerminator = 1, isReturn = 1, isBarrier = 1 in {
  def RET  : I<NoPre, 0xC9, "ret",  "", "", (outs), (ins), [(Z80retflag)]>;
  def RETN : I<EDPre, 0x45, "retn", "", "", (outs), (ins), [(Z80retnflag)]>;
  def RETI : I<EDPre, 0x4D, "reti", "", "">;
  def EI_RETI : P<(outs), (ins), [(Z80retiflag)]>;
}
let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1 in {
  let Uses = [SPS] in {
    def TCRETURN16i : P<(outs), (ins i16imm:$dst), [(Z80tcret mempat:$dst)]>,
                      Requires<[In16BitMode]>;
    def TCRETURN16r : P<(outs), (ins    A16:$dst), [(Z80tcret    A16:$dst)]>,
                      Requires<[In16BitMode]>;
  }
  let Uses = [SPL] in {
    def TCRETURN24i : P<(outs), (ins i24imm:$dst), [(Z80tcret mempat:$dst)]>,
                      Requires<[In24BitMode]>;
    def TCRETURN24r : P<(outs), (ins    A24:$dst), [(Z80tcret    A24:$dst)]>,
                      Requires<[In24BitMode]>;
  }
}

let isBranch = 1, isTerminator = 1 in {
  let isBarrier = 1 in {
    def JQ : Pseudo<"jp", "\t$dst", "", (outs), (ins jmptarget:$dst),
                    [(br bb:$dst)]>;
    def JR   : Io  <NoPre, 0x18, "jr", "\t$dst", "",
                    (outs), (ins jmptargetoff:$dst)>;
    def JP16 : I16i<NoPre, 0xC3, "jp", "\t$dst", "",
                    (outs), (ins jmptarget:$dst)>;
    def JP24 : I24i<NoPre, 0xC3, "jp", "\t$dst", "",
                    (outs), (ins jmptarget:$dst)>;
    let isIndirectBranch = 1 in {
      def JP16r : I16<NoPre, 0xE9, "jp", "\t($dst)", "",
                      (outs), (ins A16:$dst), [(brind A16:$dst)]>;
      def JP24r : I24<NoPre, 0xE9, "jp", "\t($dst)", "",
                      (outs), (ins A24:$dst), [(brind A24:$dst)]>;
    }
  }
  let Uses = [F] in {
    def JQCC : Pseudo<"jp", "\t$cc, $dst", "",
                      (outs), (ins jmptarget:$dst, cc:$cc),
                      [(Z80brcond bb:$dst, imm:$cc, F)]>;
    def JRCC   : Io  <NoPre, 0x18, "jr", "\t$cc, $dst", "",
                      (outs), (ins jmptargetoff:$dst, cc:$cc)>;
    def JP16CC : I16i<NoPre, 0xC3, "jp", "\t$cc, $dst", "",
                      (outs), (ins jmptarget:$dst, cc:$cc)>;
    def JP24CC : I24i<NoPre, 0xC3, "jp", "\t$cc, $dst", "",
                      (outs), (ins jmptarget:$dst, cc:$cc)>;
  }
}

//===----------------------------------------------------------------------===//
//  Load Instructions.
//

def LD8gg : I<NoPre, 0x40, "ld", "\t$dst, $src", "",
              (outs G8:$dst), (ins G8:$src)>;
def LD8xx : I<DDPre, 0x40, "ld", "\t$dst, $src", "",
              (outs X8:$dst), (ins X8:$src)>, Requires<[HaveIdxHalf]>;
def LD8yy : I<FDPre, 0x40, "ld", "\t$dst, $src", "",
              (outs Y8:$dst), (ins Y8:$src)>, Requires<[HaveIdxHalf]>;

let isMoveImm = 1, isReMaterializable = 1 in {
  let Defs = [F] in {
    def LD8r0   : Pseudo<"ld", "\t$dst, 0",  "",
                         (outs  R8:$dst), (ins), [(set  R8:$dst,  0)]>;
    def LD24r0  : Pseudo<"ld", "\t$dst, 0",  "",
                         (outs R24:$dst), (ins), [(set R24:$dst,  0)]>;
    def LD24r_1 : Pseudo<"ld", "\t$dst, -1", "",
                         (outs R24:$dst), (ins), [(set R24:$dst, -1)]>;
  }
  def LD8ri  : I8i <Idx0Pre, 0x06, "ld", "\t$dst, $src", "",
                    (outs  R8:$dst), (ins  i8imm:$src),
                    [(set  R8:$dst, imm:$src)]>;
  def LD16ri : I16i<Idx0Pre, 0x01, "ld", "\t$dst, $src", "",
                    (outs R16:$dst), (ins i16imm:$src),
                    [(set R16:$dst, imm:$src)]>;
  def LD24ri : I24i<Idx0Pre, 0x01, "ld", "\t$dst, $src", "",
                    (outs R24:$dst), (ins i24imm:$src),
                    [(set R24:$dst, imm:$src)]>;
}

let mayLoad = 1, canFoldAsLoad = 1, isReMaterializable = 1 in {
  let Defs = [A] in
  def LD8am  : I8i   <NoPre,   0x3A, "ld", "\ta, $src",    "",
                      (outs), (ins mem:$src), [(set A, (load mempat:$src))]>;
  def LD16rm : Pseudo<               "ld", "\t$dst, $src", "",
                      (outs R16:$dst), (ins mem:$src),
                      [(set R16:$dst, (load mempat:$src))]>;
  def LD24rm : Pseudo<               "ld", "\t$dst, $src", "",
                      (outs R24:$dst), (ins mem:$src),
                      [(set R24:$dst, (load mempat:$src))]>;
  def LD16am : I16i  <Idx0Pre, 0x2A, "ld", "\t$dst, $src", "",
                    (outs A16:$dst), (ins mem:$src)>;
  def LD24am : I24i  <Idx0Pre, 0x2A, "ld", "\t$dst, $src", "",
                    (outs A24:$dst), (ins mem:$src)>;
  def LD16om : I16i  <EDPre,   0x4B, "ld", "\t$dst, $src", "",
                    (outs O16:$dst), (ins mem:$src)>;
  def LD24om : I24i  <EDPre,   0x4B, "ld", "\t$dst, $src", "",
                    (outs O24:$dst), (ins mem:$src)>;

  def LD8rp  : Pseudo<               "ld", "\t$dst, $src", "",
                     (outs R8:$dst), (ins ptr:$src)>;
  def LD8gp  : I     <NoPre,   0x46, "ld", "\t$dst, $src", "",
                     (outs G8:$dst), (ins ptr:$src),
                     [(set G8:$dst, (load iPTR:$src))]>;
  def LD16rp : I16   <EDPre,   0x07, "ld", "\t$dst, $src", "",
                      (outs R16:$dst), (ins ptr:$src),
                      [(set R16:$dst, (load iPTR:$src))]>,
               Requires<[HaveEZ80Ops]>;
  def LD88rp : Pseudo<               "ld", "\t$dst, $src", "",
                      (outs R16:$dst), (ins ptr:$src),
                      [(set R16:$dst, (load iPTR:$src))]>;
  def LD24rp : I24   <EDPre,   0x07, "ld", "\t$dst, $src", "",
                      (outs R24:$dst), (ins ptr:$src),
                      [(set R24:$dst, (load iPTR:$src))]>;

  def LD8ro  : Pseudo<               "ld", "\t$dst, $src", "",
                     (outs R8:$dst), (ins off:$src)>;
  def LD8go  : Io    <Idx1Pre, 0x46, "ld", "\t$dst, $src", "",
                     (outs   G8:$dst), (ins off:$src),
                     [(set G8:$dst, (load offpat:$src))]>;
  def LD16ro : I16o  <Idx1Pre, 0x07, "ld", "\t$dst, $src", "",
                      (outs R16:$dst), (ins off:$src),
                      [(set R16:$dst, (load offpat:$src))]>,
               Requires<[HaveEZ80Ops]>;
  def LD88ro : Pseudo<               "ld", "\t$dst, $src", "",
                      (outs R16:$dst), (ins off:$src),
                      [(set R16:$dst, (load offpat:$src))]>;
  def LD24ro : I24o  <Idx1Pre, 0x07, "ld", "\t$dst, $src", "",
                      (outs R24:$dst), (ins off:$src),
                      [(set R24:$dst, (load offpat:$src))]>;
}
def : Pat<(i16 (extloadi8  mempat:$src)), (LD16rm mem:$src)>;
def : Pat<(i16 (extloadi8    iPTR:$src)),
          (INSERT_SUBREG (IMPLICIT_DEF), (LD8rp ptr:$src), sub_low)>;
def : Pat<(i16 (extloadi8  offpat:$src)),
          (INSERT_SUBREG (IMPLICIT_DEF), (LD8ro off:$src), sub_low)>;
def : Pat<(i24 (extloadi8  mempat:$src)), (LD24rm mem:$src)>;
def : Pat<(i24 (extloadi8    iPTR:$src)),
          (INSERT_SUBREG (IMPLICIT_DEF), (LD8rp ptr:$src), sub_low)>;
def : Pat<(i24 (extloadi8  offpat:$src)),
          (INSERT_SUBREG (IMPLICIT_DEF), (LD8ro off:$src), sub_low)>;
def : Pat<(i24 (extloadi16 mempat:$src)), (LD24rm mem:$src)>;
def : Pat<(i24 (extloadi16   iPTR:$src)), (LD24rp ptr:$src)>;
def : Pat<(i24 (extloadi16 offpat:$src)), (LD24ro off:$src)>;

let mayStore = 1 in {
  let Uses = [A] in
  def LD8ma  : I8i   <  NoPre, 0x32, "ld", "\t$dst, a",    "",
                      (outs), (ins mem:$dst), [(store A, mempat:$dst)]>;
  def LD16mr : Pseudo<               "ld", "\t$dst, $src", "",
                      (outs), (ins mem:$dst, R16:$src),
                      [(store R16:$src, mempat:$dst)]>;
  def LD24mr : Pseudo<               "ld", "\t$dst, $src", "",
                      (outs), (ins mem:$dst, R24:$src),
                      [(store R24:$src, mempat:$dst)]>;
  def LD16ma : I16i  <Idx1Pre, 0x22, "ld", "\t$dst, $src", "",
                      (outs), (ins mem:$dst, A16:$src)>;
  def LD24ma : I24i  <Idx1Pre, 0x22, "ld", "\t$dst, $src", "",
                      (outs), (ins mem:$dst, A24:$src)>;
  def LD16mo : I16i  <  EDPre, 0x43, "ld", "\t$dst, $src", "",
                      (outs), (ins mem:$dst, O16:$src)>;
  def LD24mo : I24i  <  EDPre, 0x43, "ld", "\t$dst, $src", "",
                      (outs), (ins mem:$dst, O24:$src)>;

  def LD8pr  : Pseudo<               "ld", "\t$dst, $src", "",
                      (outs), (ins ptr:$dst, R8:$src)>;
  def LD8pg  : I     <  NoPre, 0x70, "ld", "\t$dst, $src", "",
                      (outs), (ins ptr:$dst, G8:$src),
                      [(store G8:$src, iPTR:$dst)]>;
  def LD16pr : I16   <  EDPre, 0x0F, "ld", "\t$dst, $src", "",
                      (outs), (ins ptr:$dst, R16:$src),
                      [(store R16:$src, iPTR:$dst)]>,
               Requires<[In16BitMode, HaveEZ80Ops]>;
  def LD88pr : Pseudo<               "ld", "\t$dst, $src", "",
                      (outs), (ins ptr:$dst, R16:$src),
                      [(store R16:$src, iPTR:$dst)]>;
  def LD24pr : I24   <  EDPre, 0x0F, "ld", "\t$dst, $src", "",
                      (outs), (ins ptr:$dst, R24:$src),
                      [(store R24:$src, iPTR:$dst)]>;

  def LD8or  : Pseudo<               "ld", "\t$dst, $src", "",
                      (outs), (ins off:$dst, R8:$src)>;
  def LD8og  : Io    <Idx0Pre, 0x70, "ld", "\t$dst, $src", "",
                      (outs), (ins off:$dst, G8:$src),
                      [(store G8:$src, offpat:$dst)]>;
  def LD16or : I16o  <Idx0Pre, 0x0F, "ld", "\t$dst, $src", "",
                      (outs), (ins off:$dst, R16:$src)>,
               Requires<[HaveEZ80Ops]>;
}
// LD16/24or encodes R16/24:$src, but there aren't enough index registers for
// regalloc to use it, since one of the index registers is reserved as the frame
// pointer and the other is used in offpat:$dst, so just pattern match on
// G16/24:$src.
def : Pat<(store G16:$src, offpat:$dst), (LD16or off:$dst, R16:$src)>,
      Requires<[In16BitMode, HaveEZ80Ops]>;
let mayStore = 1 in {
  def LD88or : Pseudo<               "ld", "\t$dst, $src", "",
                      (outs), (ins off:$dst, R16:$src),
                      [(store R16:$src, offpat:$dst)]>;
let mayStore = 1 in
  def LD24or : I24o  <Idx0Pre, 0x0F, "ld", "\t$dst, $src", "",
                      (outs), (ins off:$dst, R24:$src)>;
}
// Same as above.
def : Pat<(store G24:$src, offpat:$dst), (LD24or off:$dst, R24:$src)>;

let mayStore = 1 in {
  def LD8pi  : I8oi  <  NoPre, 0x36, "ld", "\t$dst, $src", "",
                      (outs), (ins ptr:$dst, i8imm:$src),
                      [(store (i8 imm:$src),   iPTR:$dst)]>;
  def LD8oi  : I8oi  <Idx0Pre, 0x36, "ld", "\t$dst, $src", "",
                      (outs), (ins off:$dst, i8imm:$src),
                      [(store (i8 imm:$src), offpat:$dst)]>;
}

let Defs = [SPS] in
def LD16SP : I16<Idx0Pre, 0xF9, "ld", "\tsp, $src", "", (outs), (ins A16:$src)>;
let Defs = [SPL] in
def LD24SP : I24<Idx0Pre, 0xF9, "ld", "\tsp, $src", "", (outs), (ins A24:$src)>;

def EXAF : I<NoPre, 0x08, "ex", "\taf, af'">;
def EXX  : I<NoPre, 0xD9, "exx">;

let Defs = [DE, HL], Uses = [DE, HL] in
def EX16DE : I16<NoPre, 0xEB, "ex", "\tde, hl", "", (outs), (ins)>;
let Defs = [UDE, UHL], Uses = [UDE, UHL] in
def EX24DE : I24<NoPre, 0xEB, "ex", "\tde, hl", "", (outs), (ins)>;

let Constraints = "$imp = $arg" in {
let Uses = [SPS] in
def EX16SP : I16<Idx0Pre, 0xE3, "ex", "\t(sp), $arg", "",
                 (outs A16:$arg), (ins A16:$imp)>;
let Uses = [SPL] in
def EX24SP : I24<Idx0Pre, 0xE3, "ex", "\t(sp), $arg", "",
                 (outs A24:$arg), (ins A24:$imp)>;
}

let Uses = [SPS], Defs = [SPS] in {
  let mayLoad = 1 in {
    def POP16r  : I16 <Idx0Pre, 0xC1, "pop",  "\t$dst", "",
                       (outs S16:$dst), (ins), [(set S16:$dst, Z80pop)]>,
                  Requires<[In16BitMode]>;
  }
  let mayStore = 1 in {
    def PUSH16r : I16 <Idx0Pre, 0xC5, "push", "\t$src", "",
                       (outs), (ins S16:$src), [(Z80push S16:$src)]>,
                  Requires<[In16BitMode]>;
    def PEA16o  : I16o<EDPre,   0x65, "pea",  "\t$src", "",
                       (outs), (ins off16:$src), [(Z80push offpat:$src)]>,
                  Requires<[In16BitMode, HaveEZ80Ops]>;
  }
}
let Uses = [SPL], Defs = [SPL] in {
  let mayLoad = 1 in {
    def POP24r  : I24 <Idx0Pre, 0xC1, "pop",  "\t$dst", "",
                       (outs S24:$dst), (ins), [(set S24:$dst, Z80pop)]>;
  }
  let mayStore = 1 in {
    def PUSH24r : I24 <Idx0Pre, 0xC5, "push", "\t$src", "",
                       (outs), (ins S24:$src), [(Z80push S24:$src)]>;
    def PEA24o  : I24o<EDPre,   0x65, "pea",  "\t$src", "",
                       (outs), (ins off24:$src), [(Z80push offpat:$src)]>;
  }
}

let isReMaterializable = 1, Defs = [F] in {
  def RCF : P;
  def SCF : I<NoPre, 0x37, "scf">;
  def CCF : I<NoPre, 0x3F, "ccf">;
}

//===----------------------------------------------------------------------===//
//  Arithmetic Instructions.
//

let Defs = [A, F], Uses = [A] in {
  def CPL : I<NoPre, 0x2F, "cpl", "", "", (outs), (ins), [(set A, ( not A))]>;
  def NEG : I<EDPre, 0x44, "neg", "", "", (outs), (ins), [(set A, (ineg A))]>;
}

let Defs = [F] in
multiclass UnOp8RF<Prefix prefix, bits<8> opcode, string mnemonic,
                   Z80RC8 rc8 = !if(!eq(prefix.Value, CBPre.Value), G8, R8)> {
  def 8r : I <prefix, opcode, mnemonic, "\t$arg", "$imp = $arg",
              (outs rc8:$imp), (ins rc8:$arg),
              [(set rc8:$imp, F,
                      (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                          rc8:$arg))]>;
  def 8p : I <prefix, opcode, mnemonic, "\t$arg", "", (outs), (ins ptr:$arg),
              [(store (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                          (i8 (load iPTR:$arg))), iPTR:$arg),
               (implicit F)]>;
  def 8o : Io<prefix, opcode, mnemonic, "\t$arg", "", (outs), (ins off:$arg),
              [(store (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                          (i8 (load offpat:$arg))), offpat:$arg),
               (implicit F)]>;
}
let Defs = [F], Uses = [F] in
multiclass UnOp8RFF<Prefix prefix, bits<8> opcode, string mnemonic,
                    Z80RC8 rc8 = !if(!eq(prefix.Value, CBPre.Value), G8, R8)> {
  def 8r : I <prefix, opcode, mnemonic, "\t$arg", "$imp = $arg",
              (outs rc8:$imp), (ins rc8:$arg),
              [(set rc8:$imp, F,
                      (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                          rc8:$arg, F))]>;
  def 8p : I <prefix, opcode, mnemonic, "\t$arg", "", (outs), (ins ptr:$arg),
              [(store (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                          (i8 (load iPTR:$arg)), F), iPTR:$arg),
               (implicit F)]>;
  def 8o : Io<prefix, opcode, mnemonic, "\t$arg", "", (outs), (ins off:$arg),
              [(store (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                          (i8 (load offpat:$arg)), F), offpat:$arg),
               (implicit F)]>;
}
multiclass BinOp8RF<Prefix prefix, bits<3> opcode, string mnemonic,
                    bit compare = 0> {
  let isCompare = compare, Defs = [A, F], Uses = [A] in {
    def 8ar : I <prefix, {0b10, opcode, 0b000}, mnemonic, "\ta, $arg", "",
                 (outs), (ins    R8:$arg),
                 [(set A, F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, R8:$arg))]>;
    def 8ai : Ii<prefix, {0b11, opcode, 0b110}, mnemonic, "\ta, $arg", "",
                 (outs), (ins i8imm:$arg),
                 [(set A, F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, imm:$arg))]>;
    def 8ap : I <prefix, {0b10, opcode, 0b110}, mnemonic, "\ta, $arg", "",
                 (outs), (ins   ptr:$arg),
                 [(set A, F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, (i8 (load   iPTR:$arg))))]>;
    def 8ao : Io<prefix, {0b10, opcode, 0b110}, mnemonic, "\ta, $arg", "",
                 (outs), (ins   off:$arg),
                 [(set A, F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, (i8 (load offpat:$arg))))]>;
  }
  def : Pat<(!cast<SDNode>(mnemonic) A,  R8:$arg),
            (!cast<Instruction>(!strconcat(NAME, "8ar"))  R8:$arg)>;
  def : Pat<(!cast<SDNode>(mnemonic) A, imm:$arg),
            (!cast<Instruction>(!strconcat(NAME, "8ai")) imm:$arg)>;
  def : Pat<(!cast<SDNode>(mnemonic) A, (load iPTR:$arg)),
            (!cast<Instruction>(!strconcat(NAME, "8ap")) ptr:$arg)>;
  def : Pat<(!cast<SDNode>(mnemonic) A, (load offpat:$arg)),
            (!cast<Instruction>(!strconcat(NAME, "8ao")) off:$arg)>;
}
multiclass BinOp8RFF<Prefix prefix, bits<3> opcode, string mnemonic,
                     SDNode node, bit compare = 0> {
  let isCompare = compare, Defs = [A, F], Uses = [A, F] in {
    def 8ar : I <prefix,  {0b10, opcode, 0b000}, mnemonic, "\ta, $arg", "",
                 (outs), (ins    R8:$arg),
                 [(set A, F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, R8:$arg, F))]>;
    def 8ai : Ii<prefix,  {0b11, opcode, 0b110}, mnemonic, "\ta, $arg", "",
                 (outs), (ins i8imm:$arg),
                 [(set A, F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, imm:$arg, F))]>;
    def 8ap : I <prefix,  {0b10, opcode, 0b110}, mnemonic, "\ta, $arg", "",
                 (outs), (ins   ptr:$arg),
                 [(set A, F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, (i8 (load iPTR:$arg)), F))]>;
    def 8ao : Io<Idx1Pre, {0b10, opcode, 0b110}, mnemonic, "\ta, $arg", "",
                 (outs), (ins   off:$arg),
                 [(set A, F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, (i8 (load offpat:$arg)), F))]>;
  }
  def : Pat<(node A,  R8:$arg),
            (!cast<Instruction>(!strconcat(NAME, "8ar"))  R8:$arg)>;
  def : Pat<(node A, imm:$arg),
            (!cast<Instruction>(!strconcat(NAME, "8ai")) imm:$arg)>;
  def : Pat<(node A, (load iPTR:$arg)),
            (!cast<Instruction>(!strconcat(NAME, "8ap")) ptr:$arg)>;
  def : Pat<(node A, (load offpat:$arg)),
            (!cast<Instruction>(!strconcat(NAME, "8ao")) off:$arg)>;
}
multiclass BinOp8F<Prefix prefix, bits<3> opcode, string mnemonic,
                   bit compare = 0> {
  let isCompare = compare, Defs = [F], Uses = [A] in {
    def 8ar : I <prefix,  {0b10, opcode, 0b000}, mnemonic, "\ta, $arg", "",
                 (outs), (ins    R8:$arg),
                 [(set F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, R8:$arg))]>;
    def 8ai : Ii<prefix,  {0b11, opcode, 0b110}, mnemonic, "\ta, $arg", "",
                 (outs), (ins i8imm:$arg),
                 [(set F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, imm:$arg))]>;
    def 8ap : I <prefix,  {0b10, opcode, 0b110}, mnemonic, "\ta, $arg", "",
                 (outs), (ins   ptr:$arg),
                 [(set F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, (i8 (load iPTR:$arg))))]>;
    def 8ao : Io<Idx0Pre, {0b10, opcode, 0b110}, mnemonic, "\ta, $arg", "",
                 (outs), (ins   off:$arg),
                 [(set F,
                       (!cast<SDNode>(!strconcat("Z80", mnemonic, "_flag"))
                           A, (i8 (load offpat:$arg))))]>;
  }
}
defm RLC : UnOp8RF  <CBPre, 0, "rlc">;
defm RRC : UnOp8RF  <CBPre, 1, "rrc">;
defm RL  : UnOp8RFF <CBPre, 2, "rl">;
defm RR  : UnOp8RFF <CBPre, 3, "rr">;
defm SLA : UnOp8RF  <CBPre, 4, "sla">;
defm SRA : UnOp8RF  <CBPre, 5, "sra">;
defm SRL : UnOp8RF  <CBPre, 7, "srl">;
defm INC : UnOp8RF  <NoPre, 4, "inc">;
def : Pat<(add R8:$reg, 1), (INC8r R8:$reg)>;
defm DEC : UnOp8RF  <NoPre, 5, "dec">;
def : Pat<(add R8:$reg, -1), (DEC8r R8:$reg)>;
defm ADD : BinOp8RF <NoPre, 0, "add">;
defm ADC : BinOp8RFF<NoPre, 1, "adc", adde>;
defm SUB : BinOp8RF <NoPre, 2, "sub", 1>;
defm SBC : BinOp8RFF<NoPre, 3, "sbc", sube>;
defm AND : BinOp8RF <NoPre, 4, "and">;
defm XOR : BinOp8RF <NoPre, 5, "xor">;
defm OR  : BinOp8RF <NoPre, 6, "or">;
defm CP  : BinOp8F  <NoPre, 7, "cp",  1>;
defm TST : BinOp8F  <EDPre, 4, "tst", 1>,
           Requires<[HaveEZ80Ops]>;

let Defs = [F] in {
def INC16r : I16<Idx0Pre, 0x03, "inc", "\t$dst", "$dst = $imp",
                 (outs C16:$dst), (ins C16:$imp),
                 [(set C16:$dst, F, (Z80inc_flag C16:$imp))]>;
def INC24r : I24<Idx0Pre, 0x03, "inc", "\t$dst", "$dst = $imp",
                 (outs C24:$dst), (ins C24:$imp),
                 [(set C24:$dst, F, (Z80inc_flag C24:$imp))]>;
def DEC16r : I16<Idx0Pre, 0x0B, "dec", "\t$dst", "$dst = $imp",
                 (outs C16:$dst), (ins C16:$imp),
                 [(set C16:$dst, F, (Z80dec_flag C16:$imp))]>;
def DEC24r : I24<Idx0Pre, 0x0B, "dec", "\t$dst", "$dst = $imp",
                 (outs C24:$dst), (ins C24:$imp),
                 [(set C24:$dst, F, (Z80dec_flag C24:$imp))]>;
}
def : Pat<(add R16:$reg,  1), (INC16r R16:$reg)>;
def : Pat<(add R16:$reg, -1), (DEC16r R16:$reg)>;
def : Pat<(add R24:$reg,  1), (INC24r R24:$reg)>;
def : Pat<(add R24:$reg, -1), (DEC24r R24:$reg)>;

let Defs = [F] in {
  def ADD16aa : I16<Idx0Pre, 0x29, "add", "\t$dst, $src", "$src = $dst",
                    (outs A16:$dst), (ins A16:$src),
                    [(set A16:$dst, F, (Z80add_flag A16:$src, A16:$src))]>;
  def ADD24aa : I24<Idx0Pre, 0x29, "add", "\t$dst, $src", "$src = $dst",
                    (outs A24:$dst), (ins A24:$src),
                    [(set A24:$dst, F, (Z80add_flag A24:$src, A24:$src))]>;
  def ADD16ao : I16<Idx0Pre, 0x09, "add", "\t$dst, $src", "$imp = $dst",
                    (outs A16:$dst), (ins A16:$imp, O16:$src),
                    [(set A16:$dst, F, (Z80add_flag A16:$imp, O16:$src))]>;
  def ADD24ao : I24<Idx0Pre, 0x09, "add", "\t$dst, $src", "$imp = $dst",
                    (outs A24:$dst), (ins A24:$imp, O24:$src),
                    [(set A24:$dst, F, (Z80add_flag A24:$imp, O24:$src))]>;
  let Uses = [SPS] in
  def ADD16SP : I16<Idx0Pre, 0x39, "add", "\t$dst, sp",   "$imp = $dst",
                   (outs A16:$dst), (ins A16:$imp),
                   [(set A16:$dst, F, (Z80add_flag A16:$imp, SPS))]>;
  let Uses = [SPL] in
  def ADD24SP : I24<Idx0Pre, 0x39, "add", "\t$dst, sp",   "$imp = $dst",
                   (outs A24:$dst), (ins A24:$imp),
                   [(set A24:$dst, F, (Z80add_flag A24:$imp, SPL))]>;
}
def : Pat<(add  A16:$src, A16:$src), (ADD16aa A16:$src)>;
def : Pat<(add  A24:$src, A24:$src), (ADD24aa A24:$src)>;
def : Pat<(addc A16:$src, A16:$src), (ADD16aa A16:$src)>;
def : Pat<(addc A24:$src, A24:$src), (ADD24aa A24:$src)>;
def : Pat<(add  A16:$dst, O16:$src), (ADD16ao A16:$dst, O16:$src)>;
def : Pat<(add  A24:$dst, O24:$src), (ADD24ao A24:$dst, O24:$src)>;
def : Pat<(addc A16:$dst, O16:$src), (ADD16ao A16:$dst, O16:$src)>;
def : Pat<(addc A24:$dst, O24:$src), (ADD24ao A24:$dst, O24:$src)>;

let Defs = [HL, F] in {
  let Uses = [HL, SPS, F] in {
    def SBC16SP : I16<EDPre, 0x72, "sbc", "\thl, sp", "", (outs), (ins),
                      [(set  HL, F, (Z80sbc_flag HL, SPS, F))]>;
    def ADC16SP : I16<EDPre, 0x7A, "adc", "\thl, sp", "", (outs), (ins),
                      [(set  HL, F, (Z80adc_flag HL, SPS, F))]>;
  }
  let Uses = [HL, F] in {
    def SBC16aa : I16<EDPre, 0x42, "sbc", "\thl, hl", "", (outs), (ins),
                      [(set  HL, F, (Z80sbc_flag  HL, HL,       F))]>;
    def ADC16aa : I16<EDPre, 0x4A, "adc", "\thl, hl", "", (outs), (ins),
                      [(set  HL, F, (Z80adc_flag  HL, HL,       F))]>;
    def SBC16ao : I16<EDPre, 0x42, "sbc", "\thl, $src", "", (outs), (ins O16:$src),
                      [(set  HL, F, (Z80sbc_flag  HL, O16:$src, F))]>;
    def ADC16ao : I16<EDPre, 0x4A, "adc", "\thl, $src", "", (outs), (ins O16:$src),
                      [(set  HL, F, (Z80adc_flag  HL, O16:$src, F))]>;
  }
}
let Defs = [UHL, F] in {
  let Uses = [UHL, SPL, F] in {
    def SBC24SP : I24<EDPre, 0x72, "sbc", "\thl, sp", "", (outs), (ins),
                      [(set UHL, F, (Z80sbc_flag UHL, SPL, F))]>;
    def ADC24SP : I24<EDPre, 0x7A, "adc", "\thl, sp", "", (outs), (ins),
                      [(set UHL, F, (Z80adc_flag UHL, SPL, F))]>;
  }
  let Uses = [UHL, F] in {
    def SBC24aa : I24<EDPre, 0x42, "sbc", "\thl, hl", "", (outs), (ins),
                      [(set UHL, F, (Z80sbc_flag UHL, UHL, F))]>;
    def ADC24aa : I24<EDPre, 0x4A, "adc", "\thl, hl", "", (outs), (ins),
                      [(set UHL, F, (Z80adc_flag UHL, UHL, F))]>;
    def SBC24ao : I24<EDPre, 0x42, "sbc", "\thl, $src", "", (outs), (ins O24:$src),
                      [(set UHL, F, (Z80sbc_flag UHL, O24:$src, F))]>;
    def ADC24ao : I24<EDPre, 0x4A, "adc", "\thl, $src", "", (outs), (ins O24:$src),
                      [(set UHL, F, (Z80adc_flag UHL, O24:$src, F))]>;
  }
}
def : Pat<(sube  HL, O16:$src), (SBC16ao O16:$src)>;
def : Pat<(adde  HL, O16:$src), (ADC16ao O16:$src)>;
def : Pat<(sube UHL, O24:$src), (SBC24ao O24:$src)>;
def : Pat<(adde UHL, O24:$src), (ADC24ao O24:$src)>;

let Defs = [HL, F], Uses = [HL] in {
  def SUB16ao : P<(outs), (ins O16:$src),
                  [(set  HL, F, (Z80sub_flag  HL, O16:$src))]>;
}
let Defs = [UHL, F], Uses = [UHL] in {
  def SUB24ao : P<(outs), (ins O24:$src),
                  [(set UHL, F, (Z80sub_flag UHL, O24:$src))]>,
                Requires<[HaveEZ80Ops]>;
}
let Defs = [F] in {
  let Uses = [HL] in {
    def CP16a0 : P<(outs), (ins), [(set F, (Z80cp_flag HL, 0))]>;
    def CP16ao : P<(outs), (ins O16:$src),
                   [(set F, (Z80cp_flag HL, O16:$src))]>;
  }
  let Uses = [UHL] in {
    def CP24a0 : P<(outs), (ins), [(set F, (Z80cp_flag UHL, 0))]>,
                 Requires<[HaveEZ80Ops]>;
    def CP24ao : P<(outs), (ins O24:$src),
                   [(set F, (Z80cp_flag UHL, O24:$src))]>,
                 Requires<[HaveEZ80Ops]>;
  }
}
def : Pat<(sub   HL, O16:$src), (SUB16ao O16:$src)>;
def : Pat<(sub  UHL, O24:$src), (SUB24ao O24:$src)>;
def : Pat<(subc  HL, O16:$src), (SUB16ao O16:$src)>;
def : Pat<(subc UHL, O24:$src), (SUB24ao O24:$src)>;

def LEA16ro : I16o<EDPre, 0x02, "lea", "\t$dst, $src", "",
                   (outs R16:$dst), (ins off16:$src),
                   [(set R16:$dst, offpat:$src)]>, Requires<[HaveEZ80Ops]>;
def LEA24ro : I24o<EDPre, 0x02, "lea", "\t$dst, $src", "",
                   (outs R24:$dst), (ins off24:$src),
                   [(set R24:$dst, offpat:$src)]>;

def MLT8rr : I<EDPre, 0x4C, "mlt", "\t$dst", "$src = $dst",
               (outs G16:$dst), (ins G16:$src),
               [(set G16:$dst, (Z80mlt G16:$src))]>, Requires<[HaveZ180Ops]>;

//===----------------------------------------------------------------------===//
// Non-Instruction Patterns.
//===----------------------------------------------------------------------===//

// addresses
def : Pat<(i16 (Z80Wrapper tglobaladdr  :$src)), (LD16ri tglobaladdr  :$src)>;
def : Pat<(i24 (Z80Wrapper tglobaladdr  :$src)), (LD24ri tglobaladdr  :$src)>;
def : Pat<(i16 (Z80Wrapper texternalsym :$src)), (LD16ri texternalsym :$src)>;
def : Pat<(i24 (Z80Wrapper texternalsym :$src)), (LD24ri texternalsym :$src)>;
def : Pat<(i16 (Z80Wrapper tblockaddress:$src)), (LD16ri tblockaddress:$src)>;
def : Pat<(i24 (Z80Wrapper tblockaddress:$src)), (LD24ri tblockaddress:$src)>;

// calls
def : Pat<(Z80call (tglobaladdr :$dst)), (CALL16i tglobaladdr :$dst)>,
      Requires<[In16BitMode]>;
def : Pat<(Z80call (tglobaladdr :$dst)), (CALL24i tglobaladdr :$dst)>,
      Requires<[In24BitMode]>;
def : Pat<(Z80call (texternalsym:$dst)), (CALL16i texternalsym:$dst)>,
      Requires<[In16BitMode]>;
def : Pat<(Z80call (texternalsym:$dst)), (CALL24i texternalsym:$dst)>,
      Requires<[In24BitMode]>;

def : Pat<(Z80tcret (tglobaladdr :$dst)), (TCRETURN16i tglobaladdr :$dst)>,
      Requires<[In16BitMode]>;
def : Pat<(Z80tcret (tglobaladdr :$dst)), (TCRETURN24i tglobaladdr :$dst)>,
      Requires<[In24BitMode]>;
def : Pat<(Z80tcret (texternalsym:$dst)), (TCRETURN16i texternalsym:$dst)>,
      Requires<[In16BitMode]>;
def : Pat<(Z80tcret (texternalsym:$dst)), (TCRETURN24i texternalsym:$dst)>,
      Requires<[In24BitMode]>;

//===----------------------------------------------------------------------===//
// Subsystems.
//===----------------------------------------------------------------------===//

// Any instruction that defines a 16-bit result leaves the high half of the
// register zero. Truncate can be lowered to EXTRACT_SUBREG. CopyFromReg may
// be copying from a truncate. But any other 16-bit operation will zero-extend
// up to 24 bits.
//def def16 : PatLeaf<(i16 R16:$src), [{
//  dbgs() << "Hello World!\n";
//  return N->getOpcode() != ISD::TRUNCATE &&
//         N->getOpcode() != TargetOpcode::EXTRACT_SUBREG &&
//         N->getOpcode() != ISD::CopyFromReg;
//}]>;

// In the case of a 16-bit def that is known to implicitly zero-extend,
// we can use a SUBREG_TO_REG.
//def : Pat<(i24 (zext def16:$src)),
//          (SUBREG_TO_REG (i24 0), R16:$src, sub_short)>;

//def : Pat<(i24 (Z80sub_flag UHL, G24:$src)), (SBC24ar G24:$src, RCF)>;

// mlt
//def : Pat<(i8 (mul R8:$arg1, R8:$arg2)),
//          (SUBREG_TO_REG (i24 0), (MLT8rr (INSERT_SUBREG R8:$arg1)), sub_low)>;

/*def : Pat<(i32 (imm:$src)),
          (REG_SEQUENCE R32, (LD24ri (imm_long_XFORM imm:$src)), sub_long,
                             (LD8ri (imm_top_XFORM imm:$src)), sub_top)>;*/

// anyexts
def : Pat<(i16 (anyext R8 :$src)),
          (INSERT_SUBREG (IMPLICIT_DEF), R8 :$src, sub_low)>;
def : Pat<(i24 (anyext R8 :$src)),
          (INSERT_SUBREG (IMPLICIT_DEF), R8 :$src, sub_low)>;
def : Pat<(i24 (anyext R16:$src)),
          (INSERT_SUBREG (IMPLICIT_DEF), R16:$src, sub_short)>;
/*def : Pat<(i32 (anyext R8 :$src)),
          (INSERT_SUBREG (IMPLICIT_DEF), R8 :$src, sub_low)>;
def : Pat<(i32 (anyext R16:$src)),
          (INSERT_SUBREG (IMPLICIT_DEF), R16:$src, sub_short)>;
def : Pat<(i32 (anyext R24:$src)),
          (INSERT_SUBREG (IMPLICIT_DEF), R24:$src, sub_long)>;*/

// zexts
def : Pat<(i16 (zext R8 :$src)),
          (REG_SEQUENCE R16, R8 :$src, sub_low, (LD8ri 0), sub_high)>;
def : Pat<(i24 (zext R8 :$src)),
          (INSERT_SUBREG (i24 0), R8 :$src, sub_low)>;
def : Pat<(i24 (zext R16:$src)),
          (INSERT_SUBREG (i24 0), R16:$src, sub_short)>;
/*def : Pat<(i32 (zext R8:$src)),
          (REG_SEQUENCE R32, (INSERT_SUBREG (i24 0), R8:$src,
                                            sub_low), sub_long,
                             (i8 0), sub_top)>;
def : Pat<(i32 (zext R16:$src)),
          (REG_SEQUENCE R32, (INSERT_SUBREG (i24 0), R16:$src,
                                            sub_short), sub_long,
                             (i8 0), sub_top)>;
def : Pat<(i32 (zext R24:$src)),
          (REG_SEQUENCE R32, R24:$src, sub_long, (i8 0), sub_top)>;*/

// truncs
def : Pat<(i8  (trunc R16:$src)), (EXTRACT_SUBREG R16:$src, sub_low)>;
def : Pat<(i8  (trunc R24:$src)), (EXTRACT_SUBREG R24:$src, sub_low)>;
def : Pat<(i16 (trunc R24:$src)), (EXTRACT_SUBREG R24:$src, sub_short)>;
/*def : Pat<(i8  (trunc R32:$src)), (EXTRACT_SUBREG R32:$src, sub_low)>;
def : Pat<(i16 (trunc R32:$src)), (EXTRACT_SUBREG R32:$src, sub_short)>;
def : Pat<(i24 (trunc R32:$src)), (EXTRACT_SUBREG R32:$src, sub_long)>;*/

// loads
//def : Pat<(i32 (load mempat:$src)), (REG_SEQUENCE R32, (LD24rm mempat:$src), sub_long, (LD8am (imm_add_3_XFORM mempat:$src)), sub_top)>;
//def : Pat<(i32 (load   iPTR:$src)), (REG_SEQUENCE R32, (LD24rp   iPTR:$src), sub_long, (LD8rp (fi_add_3_XFORM iPTR:$src)), sub_top)>;
//def : Pat<(i32 (load offpat:$src)), (REG_SEQUENCE R32, (LD24ro offpat:$src), sub_long, (LD8ro offpat:$src), sub_top)>;
//def : Pat<(i32 (load iPTR:$src)), (REG_SEQUENCE R32, (i8 0), sub_top, (LD24rp iPTR:$src), sub_long)>;
//def : Pat<(i32 (load iPTR:$src)), (REG_SEQUENCE R32, (R8 (LD8rp (imm_add_3_XFORM iPTR:$src))), sub_top,
//                                                     (R24 (LD24rp iPTR:$src)), sub_long)>;
